package Hilbert;

import Matricies.Point;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import tools.ArgMinContainer;

/**
 *
 * @author Dov Neimand
 */
public class PCone<Vec extends Vector<Vec>> {

    protected final List<HalfSpace<Vec>> allHalfSpaces;
    public final PCone immediateSuperCone;
    private PCone<Vec>[] subcones;
    private final PCone<Vec> hilbertCone;
    private final int[] hsIndicies;
    private PCone<Vec>[] superCones;

    protected ArgMinContainer<Vec> savedArgMin;

    
    /**
     * The constructor for a p-cone that is the Hilbert Space
     *
     * @param halfSpaceList
     * @param f
     * @param superCones
     */
    public PCone(List<HalfSpace<Vec>> halfSpaceList) {
        this(-1, halfSpaceList, null, null);
    }
    
    /**
     * The number of halfspaces that intersect to make this cone.
     * @return 
     */
    public int codim(){
        return hsIndicies.length;
    }

    /**
     * The constructor.
     *
     * @param halfSpaceindex
     * @param halfSpaceList
     * @param immediateSuperCone
     * @param hilbertCone
     */
    public PCone(int halfSpaceindex, List<HalfSpace<Vec>> halfSpaceList, PCone<Vec> immediateSuperCone, PCone<Vec> hilbertCone) {
        this.allHalfSpaces = halfSpaceList;
        this.immediateSuperCone = immediateSuperCone;
        this.hilbertCone = hilbertCone;
        
        hsIndicies = immediateSuperCone != null? 
                new int[immediateSuperCone.hsIndicies.length + 1]:
                new int[0];

        if (hsIndicies.length > 1)
            System.arraycopy(immediateSuperCone.hsIndicies, 0,
                    hsIndicies, 0,
                    hsIndicies.length - 1);
        if (hsIndicies.length > 0) hsIndicies[hsIndicies.length - 1] = halfSpaceindex;
    }

    /**
     * gets the intersection of this cone and the halfspace with the proffered
     * index.
     *
     * @param halfSpaceIndex the index of the halfspace that is to intersect
     * this cone.
     * @return A subcone of this cone.
     */
    public PCone<Vec> subCone(int halfSpaceIndex) {
        if(subcones == null) setSubCones();
        int lastIndex = (codim() == 0? 0:hsIndicies[codim() - 1] + 1);
        return subCone0Ind(halfSpaceIndex - lastIndex);
    }
    
    /**
     * returns the subcone that is stored at the given index in the array of 
     * subcones.  If there is no cone at that index, one is created and saved.
     * @param i
     * @return 
     */
    public PCone<Vec> subCone0Ind(int i){
        if(subcones[i] != null) return subcones[i];
        else return subcones[i] = new PCone<>(
                        i + (codim() > 0 ? hsIndicies[codim() - 1] + 1 : 0),
                        allHalfSpaces,
                        this,
                        hilbertCone == null ? this : hilbertCone);
    }

    /**
     * Creates the array of subcones, initially empty.
     */
    private void setSubCones() {
        int halfSpaceIndex = hsIndicies.length > 0? hsIndicies[hsIndicies.length - 1]: -1;
        subcones = new PCone[allHalfSpaces.size() - halfSpaceIndex - 1];
    }
    

    /**
     * The immediate subcones of this cone.
     *
     * @return
     */
    public Stream<PCone<Vec>> immediateSubCones() {

        if(subcones == null) setSubCones();
        return IntStream.range(0, subcones.length).mapToObj(i -> subCone0Ind(i));
    }

    /**
     * The superspace generated by removing the half space with the proffered
     * index from the set of half spaces that intersect to make this cone.
     *
     * @param i
     * @return
     */
    public PCone<Vec> immidiateSuper(int i) {

        
        PCone<Vec> superCone = hilbertCone;
        for (int j = 0; j < codim() && superCone != null; j++)
            if (i != j)
                superCone = superCone.subCone(hsIndicies[j]);
        
        return superCone;
    }

    /**
     * The affine space from which this cone emanates
     *
     * @return
     */
    public AffineSpace<Vec> affineSpace() {
        if (hsIndicies.length == 0) return AffineSpace.<Vec>allSpace();
        Vec[] normals = (Vec[]) (Array.newInstance(getHS(0).normal().getClass(), codim()));
        Point b = new Point(codim());

        for (int i = 0; i < codim(); i++) {
            HalfSpace<Vec> hs = getHS(i);
            normals[i] = hs.normal();
            b.data[i] = hs.boundry.b();
        }
        return new AffineSpace(normals, b);
    }

    /**
     * The argmin of this pcone.
     *
     * @return
     */
    public ArgMinContainer<Vec> aMin(StrictlyConvexFunction<Vec> f) {
        
        if(savedArgMin != null) return savedArgMin;
        
        for (int i = 0; i < codim(); i++) {
            ArgMinContainer<Vec> argMinSuper = immidiateSuper(i).aMin(f);
            if(argMinSuper.isPolyhedralMin) return argMinSuper;
            
            if (getHS(i).hasElement(argMinSuper.argMin()))
                return savedArgMin = new ArgMinContainer(argMinSuper.argMin(), false);
        }
        
        Vec aMin = f.argMin(affineSpace());
        
        return savedArgMin = new ArgMinContainer(aMin, allHalfSpaces.parallelStream().allMatch(hs -> hs.hasElement(aMin)));
        
        
    }

    /**
     * gets the half space with the given index in the cones list of halfspaces.
     * @param i the index in the list of halfspaces that intersect to make this cone.
     * @return 
     */
    public HalfSpace<Vec> getHS(int i) {
        return allHalfSpaces.get(hsIndicies[i]);
    }
    
    /**
     * 
     * @param i the index of  half space in the list of halfspaces that intersect
     * to make this cone.
     * @return The index of the same half space in the list of all halfspaces
     * of the polyhedron.
     */
    public int halfSpaceInd(int i){
        return hsIndicies[i];
    }
    

    @Override
    public String toString() {
        return IntStream.range(0, codim()).mapToObj(i -> getHS(i)).toList().toString();
    }
    
    /**
     * Does this cone have a saved argMin
     * @return 
     */
    public boolean hasArgMin() {
        return savedArgMin != null;
    }

    
    /**
     * Saves the immediated supercones of this cone for faster access.
     */
    public void saveSuperCones(){
        if(superCones == null) superCones = (PCone<Vec>[]) (Array.newInstance(getClass(), codim()));
        Arrays.parallelSetAll(superCones, i -> {
            if(superCones[i] == null) return immidiateSuper(i);
            return superCones[i];
        });
    }
    
    /**
     * Have the supercones of this cone found their argmins.
     * @return true if they have, false otherwise.
     */
    public boolean isReady(){
        saveSuperCones();
        return Arrays.stream(superCones).allMatch(cone -> cone != null && cone.hasArgMin());
    }
    
}
