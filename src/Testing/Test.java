package Testing;

import Convex.LinearRn.ProhjectOntoAffine;
import Hilbert.HalfSpace;
import Hilbert.Optimization.PolyhedralMin;
import Hilbert.StrictlyConvexFunction;
import Hilbert.Vector;
import Matricies.Point;
import java.math.BigDecimal;
import java.math.MathContext;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;

/**
 *
 * @author Dov Neimand
 */
public class Test<Vec extends Vector<Vec>> {


    private List<Vec> argMins;
    private List<Double> times;
    private List<Double> fractions;
    private final double MILI_PER_SEC = 1000.0;

    /**
     * The significant digits of a number.
     *
     * @param n the number of significant digits
     * @param d the number the significant digits are taken from.
     * @return the first n significant digits of a d.
     */
    private double sigDigits(int n, double d) {
        BigDecimal bd = new BigDecimal(d);
        bd = bd.round(new MathContext(n));
        return bd.doubleValue();
    }
    
    /**
     * This method should be called for each entry in the table being printed
     *
     * @param numTests how many tests do we wish to run for each entry
     * @param numDim the dimension of the space containing the polyhedrons we
     * wish to test
     * @param numFaces the number of half spaces intersecting to form the
     * polyhedron we wish to test.
     * @param isTime true if we want to know how much time this takes, false if
     * we want to know how many halfspaces are tested
     * @param timeOrFrac true if you want a table of time values, false if you
     * want the fraction of affine spaces computed.
     * @return the table value
     */
    public Test(int numTests, List<HalfSpace<Vec>> poly,  StrictlyConvexFunction<Vec> f) {
        argMins = new ArrayList<>(numTests);
        times = new ArrayList<>(numTests);
        fractions = new ArrayList<>(numTests);

        for (int i = 0; i < numTests; i++) {
            
            PolyhedralMin<Vec> pm = new PolyhedralMin<>(f, poly);
            
            double startTime = System.currentTimeMillis();
            
            Vec aMin = pm.argMin();
            
            double time = System.currentTimeMillis() - startTime;
                        
            argMins.add(aMin);
            times.add((double)time / MILI_PER_SEC);
            fractions.add(pm.fracAffineSpacesChecked());
        }

    }
    
    
    /**
     * The average of the elements of this list.
     * @param list
     * @return 
     */
    private double avg(List<Double> list){
        return list.stream().mapToDouble(d -> d).average().getAsDouble();
    }
    
    /**
     * The variance of the list
     * @param list
     * @return 
     */
    private double variance(List<Double> list){
        double avg = avg(list);
        return list.stream().mapToDouble(d -> Math.pow(d - avg, 2)).average().getAsDouble();
    }
    
    /**
     * The average amount of times.
     * @return 
     */
    public double averageTimes(){
        return sigDigits(3, avg(times));
    }
    
    /**
     * The average fraction of the number of affine spaces on which we call the
     * black box function over the total number of affine spaces.
     * @return 
     */
    public double averagFrac(){
        return sigDigits(3, avg(fractions));
    }
    
    /**
     * The variance of the times
     * @return 
     */
    public double timeVariance(){
        return variance(times);
    }
    
    /**
     * The variance of the fractions.
     * @return 
     */
    public double fracVariance(){
        return variance(fractions);
    }

    /**
     * The set of argmins generated by running this test.
     * @return 
     */
    public List<Vec> getArgMins() {
        return Collections.unmodifiableList(argMins);
    }
    
    
}
